# 实现Qt客户端的 HTTP 管理类，发送Http请求的底层类，供上层各个模块调用（比如注册模块发验证码Post、登录界面发登录Post等等，但不管怎样通用的Http长度，大小端等由这个类负责。）

## 功能概述
实现发送 HTTP 请求、接受处理 HTTP 请求等功能，并结合 Qt 的信号和槽机制进行通信。

## 信号和槽机制
Qt 的信号和槽机制是 Qt 框架的核心特性之一，用于实现对象之间的通信。它提供了一种灵活且类型安全的方式来处理事件和回调，而无需直接使用回调函数或委托。信号的调用会触发与之连接的槽函数，通过联接绑定信号和相应的槽函数。

## 一、Register 类

这个类需要做的事情：
1. 获取验证码的按键对应的 `on_get_code_clicked` 事件（用正则表达式检查邮箱格式是否匹配，匹配则发送 HTTP 请求，否则返回提示）。
2. 初始化一个单例模式的 `initHttpHandler`，用于处理不同的 HTTP 请求响应。根据 `req_id` 调用不同函数。
3. 槽函数用于根据注册请求的结果做不同处理（显示错误原因），后面 `HttpMgr` 会发送的信号，这里相当于回调。
4. UI 界面展示 `showtip`。

## 二、HttpMgr 类

首先把它做成一个单例类：这样方便在任何需要发送 HTTP 请求的时候调用。这里我们使用饿汉模式，第一次调用时进行一次初始化。使用智能指针管理，自动释放。

一个细节就是模版参数 `T` 后续写成子类的类对象。这种 CRTP 奇异模板递归是一种静态多态的体现，运行时才确定模板对象，但是无需查虚表，减少开销。

他要做的事情：
1. 发送 HTTP 请求 `PostHttpReq` 函数，接受四个参数：请求的 URL，请求的数据（JSON 或者 Protobuf 序列化），以及请求的 ID，以及哪个模块发出的请求 `mod`。
   - 之所以需要请求的 ID 和模块，一方面是面向对象思想，将功能模块化，功能明确，方便新增功能以及出了问题好管理。
   - 二是因为处理是异步的，回调不知道什么时候触发，用他们来进行区分。
   - 函数逻辑：通过 QT 的 Network 模块自带的 `QNetworkRequest` 来实现，我们只需要填入请求头部（包体长度、字节序列化的方式），和 URL 即可。
   - 填充包体长度避免粘包，跟 TCP 应该类似的逻辑，好像一般默认。Java、Go 等语言的库会封装好这些事情。

2. 发送 HTTP 信号，等请求完成。错误则提示 `qDebug` 后，发送信号通知请求 ID 和模块完成；正确则直接通知发送完成。

3. 处理响应：上面槽函数触发，根据 `Mod` 让相应模块做处理，相应模块再根据 `req_id` 做不同处理（就是上面的一 3）。

这些是任意一个 HTTP 请求，无论 GET、POST 等等都要做的事情，然后根据接受的请求 ID 和请求模块通知槽函数处理。

## 实现步骤

先实现注册模块。

## 三、7.26补充：回头看，之前写的这些太草率了，甚至都没梳理清楚。重新梳理一下服务器的逻辑